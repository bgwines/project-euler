{- If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.

As an example, let us consider the sequence of cube numbers. This is defined by the generating function, 
un = n3: 1, 8, 27, 64, 125, 216, ...

Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.

We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for the first k terms of a sequence. It should be clear that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, and potentially the first incorrect term (FIT) will be OP(k, k+1); in which case we shall call it a bad OP (BOP).

As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u1.

Hence we obtain the following OPs for the cubic sequence:

OP(1, n) = 1	1, 1, 1, 1, ...
OP(2, n) = 7n−6	1, 8, 15, ...
OP(3, n) = 6n2−11n+6     	1, 8, 27, 58, ...
OP(4, n) = n3	1, 8, 27, 64, 125, ...
Clearly no BOPs exist for k ≥ 4.

By considering the sum of FITs generated by the BOPs (indicated in red above), we obtain 1 + 15 + 58 = 74.

Consider the following tenth degree polynomial generating function:

un = 1 − n + n2 − n3 + n4 − n5 + n6 − n7 + n8 − n9 + n10

Find the sum of FITs for the BOPs. -}

{- Notice:
	find the c_i (`c` for "coefficient") s.t.

					 n=0:
                     c_0 = 1

			  n=1:
              2c_1 + c_0 = 8
              1c_1 + c_0 = 1

	   n=2:
       9c_2 + 3c_1 + c_0 = 27
       4c_2 + 2c_1 + c_0 = 8
       1c_2 + 1c_1 + c_0 = 1

n=3:
64c_3 + 16c_2 + 4c_1 + c_0 = 64
27c_3 +  9c_2 + 3c_1 + c_0 = 27
 8c_3 +  4c_2 + 2c_1 + c_0 = 8
 1c_3 +  1c_2 + 1c_1 + c_0 = 1

More generally, (watch out for off_by_one)

  [ (n+1)^n, ... (n+1)^0] [c_n]   [t_n]

             ...           ...  =  ...

  [  1^n   , ...   1^0  ] [c_1]   [t_1]

          N                 C   =   T

        NC = T
        C = (N^-1)T

    N, T known -}

{-# LANGUAGE ScopedTypeVariables #-}

import qualified Zora.List as ZList
import qualified Zora.Math as ZMath

import qualified Data.Ord as Ord
import qualified Data.Set as Set
import qualified Data.List as List

import qualified Data.MemoCombinators as Memo

import Data.Maybe

import Control.Applicative

linear_system_of_degree :: Int -> [[Double]]
linear_system_of_degree degree
	= map reverse
	$ [ [ fromIntegral (n^e)
	    | e <- [0..degree]]
	  | n <- [1..(degree + 1)] ]

polynomial :: Double -> Double
polynomial n = 1 - n^1 + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10

ub :: Double
ub = 10

poly_terms_seqs :: [[Double]]
poly_terms_seqs
	= tail
	. List.inits
	. map polynomial
	$ [1..ub]

-- Interpolated from Mathematica -- ZMath's is subject to rounding errors for large numbers.
interpolated_polynomials :: [[Double]]
interpolated_polynomials = [[1], [682, -681], [21461, -63701, 42241], [118008, -686587, 
  1234387, -665807], [210232, -1984312, 6671533, -9277213, 
  4379761], [159060, -2175668, 11535788, -29116967, 
  34305227, -14707439], [58542, -1070322, 8069182, -31492582, 
  65955241, -68962861, 27442801], [11165, -254078, 2524808, -13814218,
   44083303, -80663539, 76941359, -28828799], [1111, -28831, 
  352528, -2514688, 11126621, -30669221, 50572225, -44806465, 
  15966721], [54, -1319, 18149, -157772, 902054, -3416929, 
  8409499, -12753575, 10628639, -3628799]]

interpolated_polynomials' :: [[Double]]
interpolated_polynomials'
	= (:) [1.0]
	$ map
		(\poly_terms_seq ->
			ZMath.solve_linear_system
			(linear_system_of_degree $ pred . length $ poly_terms_seq)
			poly_terms_seq)
		$ tail poly_terms_seqs

eval_poly :: [Double] -> Double -> Double
eval_poly coeffs n
	= sum
	. map (\(e, coeff) -> coeff * (n^e))
	$ reverse . zip [0..] . reverse $ coeffs

fits :: [Double]
fits
	= map
		(\coeffs -> eval_poly coeffs (fromIntegral . succ . length $ coeffs))
		interpolated_polynomials

main :: IO ()
main = do
	putStrLn . show $ round . sum $ fits
